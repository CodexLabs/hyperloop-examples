/**
 * Hyperloop Metabase Generator
 * Copyright (c) 2015 by Appcelerator, Inc.
 */
var acorn = require('acorn'),
	fs = require('fs'),
	path = require('path'),
	util = require('util'),
	utillib = require('./util'),
	walk = require('walk-ast'),
	classgen = require('./class');

function Parser () {
}

function ParserState (state) {
	this.state = state;
}

function JSParseError (message, node) {
	this.line = (node.loc  || node.location).start.line;
	this.column = (node.loc || node.location).start.column;
	this.filename = (node.loc || node.location).filename;
	this.message = message + ' (' + this.filename + ':' + this.line + ':' + this.column + ')';
	Error.captureStackTrace(this, JSParseError);
}

JSParseError.prototype = Object.create(Error.prototype);
JSParseError.prototype.name = "JSParseError";
JSParseError.prototype.constructor = JSParseError;

ParserState.prototype.getClassNames = function () {
	return Object.keys(this.state.classesByName);
};

ParserState.prototype.getClassNamed = function (name) {
	return this.state.classesByName[name];
};

function count (str, find) {
	var re = new RegExp(find, 'g');
	var found = str.match(re);
	return found && found.length || 0;
}

function decodeStruct(str, offset) {
	offset = offset == undefined ? 0 : offset;
	var i = str.indexOf('}', offset);
	while ( i != -1) {
		var struct = str.substring(offset, i + 1);
		if (count(struct, '{') === count(struct, '}')) {
			return struct;
		}
		i = str.indexOf('}', i + 1);
	}
	return str;
}

function getEncoding (metabase, imports, str, index) {
	var ch = str.charAt(index);
	switch (ch) {
		// skip these
		case 'r': case 'n': case 'N': case 'o': case 'O': case 'R': case 'V': {
			return { value: '' };
		}
		case 'i': return { value: 'int', encoding: ch, type: 'int' };
		case 'd': return { value: 'double', encoding: ch, type: 'double' };
		case 'f': return { value: 'float', encoding: ch, type: 'float' };
		case 'l': return { value: 'long', encoding: ch, type: 'long' };
		case 's': return { value: 'short', encoding: ch, type: 'short' };
		case 'c': return { value: 'char', encoding: ch, type: 'char' };
		case 'B': return { value: 'bool', encoding: ch, type: 'bool' };
		case 'q': return { value: 'long long', encoding: ch, type: 'long long' };
		case 'C': return { value: 'unsigned char', encoding: ch, type: 'unsigned char' };
		case 'I': return { value: 'unsigned int', encoding: ch, type: 'unsigned int' };
		case 'S': return { value: 'unsigned short', encoding: ch, type: 'unsigned short' };
		case 'L': return { value: 'unsigned long', encoding: ch, type: 'unsigned long' };
		case 'Q': return { value: 'unsigned long long', encoding: ch, type: 'unsigned long long' };
		case '#': return { value: 'Class', encoding: ch, type: 'Class' };
		case ':': return { value: 'SEL', encoding: ch, type: 'SEL' };
		case '*': return { value: 'char *', encoding: ch, type: 'char *' };
		case 'v': return { value: 'void', encoding: ch, type: 'void' };
		case '?': return { value: 'void *', encoding: ch, type: 'void *' };
		case '{': {
			// structure, parse it
			var enc = decodeStruct(str, index);
			var skip = enc.length - 1;
			var i = enc.indexOf('=');
			var value = 'void *';
			if (i > 0) {
				var name = enc.substring(1, i);
				var struct = metabase.structs[name];
				value = struct && struct.name || enc;
			}
			return {
				type: 'struct',
				value: value,
				skip: skip,
				encoding: enc
			};
		}
		case '@': {
			var skip = 0;
			// block
			if (str.charAt(index + 1) === '?') {
				skip = 1;
			}
			return {
				value: 'id',
				skip: skip,
				type: 'objc_interface',
				encoding: skip ? '@?': '@'
			};
		}
		case '^': {
			// pointer
			var enc = getEncoding(metabase, imports, str, (index || 0) + 1);
			return {
				value: enc.value + ' *',
				skip: enc.skip || (enc.value.length - 2),
				encoding: '^' + enc.encoding,
				type: enc.value + ' *'
			}
		}
	}
	throw new Error("unknown encoding " + ch);
}

function parseEncoding (metabase, imports, encoding) {
	var i = encoding.indexOf('@:');
	var rt = encoding.substring(0, i);
	var argtypes = encoding.substring(i + 2);
	var args = [];
	for (var c = 0; c < argtypes.length; c++) {
		var encoding = getEncoding(metabase, imports, argtypes, c);
		encoding.value && args.push(encoding);
		c += encoding.skip || 0;
	}
	return {
		returns: getEncoding(metabase, imports, rt, 0),
		args: args
	};
}

function generateIdentifier (selector, instance, cls) {
	return utillib.generateSafeSymbol(cls.name + '_' + selector + '_' + (instance ? '1': '0'));
}

function generateMethod (metabase, imports, cls, classDef, selector, encoding, instance, body) {
	var details = parseEncoding(metabase, imports, encoding),
		argnames = selector.split(':'),
		code = [],
		identifier = generateIdentifier(selector, instance, classDef),
		methodName = utillib.camelCase(selector);

	//TODO: if we are extended a class or implementing a protocol and overriding
	//the method, we can just look up the method so that the developer doesn't have
	//to specify the encoding

	// add the class for JS generation later
	var addMethod;
	if (!(methodName in cls.methods)) {
		cls.methods[methodName] = {
			name: methodName,
			arguments: [],
			returns: details.returns,
			instance: instance
		};
		addMethod = true;
	}

	var method = (instance ? '-' : '+') + '(' + details.returns.value + ')' + argnames[0];
	details.args.forEach(function (arg, index) {
		var name = argnames[index];
		if (index) {
			method+=' '+name;
		}
		method+=':('+arg.value+')arg' + index;
		if (addMethod) {
			arg.name = argnames[index];
			cls.methods[methodName].arguments.push(arg);
		}
		utillib.resolveArg(metabase, imports, arg);
	});

	if (body) {
		code.push(method + ' {');

		var argnames = [],
			isVoid = details.returns.type === 'void';

		code.push('\t@autoreleasepool {');
		if (!isVoid) {
			code.push('\t\t__block id result_ = nil;');
		}
		code.push('\t\tvoid(^Callback)(void) = ^{')
		details.args.forEach(function (arg, i) {
			if (utillib.isObjectType(arg.type, arg.encoding)) {
				code.push('\t\t\t' + utillib.getObjCReturnResult(arg, 'arg' + i, 'id _arg' + i +' =', ''));
			} else {
				code.push('\t\t\t' + utillib.getObjCReturnResult(arg, 'arg' + i, 'id _arg' + i +' ='));
			}
			argnames.push('_arg' + i);
		});

		code.push('\t\t\t' + (isVoid ? '' : 'result_ = ') + '[HyperloopUtils invokeCustomCallback:@[' + argnames.join(', ') + '] identifier:@"' + identifier + '"];');

		code.push('\t\t};');

		code.push('\t\tif ([NSThread isMainThread]) {');
		code.push('\t\t\tCallback();');
		code.push('\t\t} else {');
		code.push('\t\t\tdispatch_sync(dispatch_get_main_queue(), Callback);');
		code.push('\t\t}');

		if (!isVoid) {
			code.push('\t\t' + details.returns.value + ' result$;');
			code.push('\t\tif (result_ && [result isKindOfClass:[HyperloopPointer class]]) {');
			code.push('\t\t' + utillib.generateObjCValue({imports:imports}, metabase, details.returns, details.returns, 'result', '\t\t'));
			code.push('\t\t\tresult$ = result;');
			if (utillib.isObjectType(details.returns.type, details.returns.encoding)) {
				code.push('\t\t} else if ([result isEqual:[NSNull null]]==NO) {')
				code.push('\t\t\tresult$ = result;');
			}
			code.push('\t\t}');
			code.push('\t\treturn result$;');
		}

		code.push('\t}');
		code.push('}');
	} else {
		code.push(method + ';');
	}

	return code.join('\n');
}

Parser.generate = function (dir, state, metabase) {
	if (state && Object.keys(state.getClassNames())) {
		var code = [], imports = {};
		state.getClassNames().forEach(function (name) {
			var classDef = state.getClassNamed(name);
			var protocols = '';
			var found;
			var cls = { methods: {}, name: name, framework: 'Hyperloop', superclass: classDef.extends };
			if (!(found = metabase.classes[classDef.extends])) {
				throw new JSParseError('invalid class specified "' + classDef.extends + '"', classDef);
			}
			imports[found.framework + '/' + found.name] = 1;
			if (classDef.implements) {
				if (typeof(classDef.implements)) {
					if (!(found = metabase.classes[classDef.implements])) {
						throw new JSParseError('invalid class specified "' + classDef.implements + '"', classDef);
					}
					imports[found.framework + '/' + found.name] = 1;
					protocols = [classDef.implements];
				} else {
					protocols = classDef.implements;
					protocols.forEach(function (n) {
						if (!(found = metabase.protocols[n])) {
							throw new JSParseError('invalid protocol specified "' + n + '"', classDef);
						}
						imports[found.framework + '/' + found.name] = 1;
					});
				}
				console.log('protocols', protocols);
				protocols && protocols.length && (protocols = ' <' + protocols.join(', ') + '>');
			}
			code.push('/**');
			code.push(' * user class defined at ' + classDef.location.filename + ':' + classDef.location.start.line);
			code.push(' */');
			code.push('@interface ' + classDef.name + ' : ' + classDef.extends + protocols);
			code.push('');
			var methods = classDef.methods;
			var interfaces = [], implementations = [];
			methods && Object.keys(methods).forEach(function (m) {
				var method = methods[m];
				interfaces.push(generateMethod(metabase, imports, cls, classDef, method.selector, method.encoding, method.instance));
				implementations.push(generateMethod(metabase, imports, cls, classDef, method.selector, method.encoding, method.instance, true));
				interfaces.push('');
				implementations.push('');
			});
			code.push(interfaces.join('\n'));
			code.push('@end');
			code.push('');
			code.push('@implementation ' + classDef.name);
			code.push('');
			code.push(implementations.join('\n'));
			code.push('@end');
			code.push('');

			// generate the JS class
			classgen.generate(dir, metabase, cls);
		});

		var output = utillib.generateTemplate('custom.m', {
			data: {
				code: code.join('\n'),
				imports: imports
			}
		});
		utillib.generateFile(dir, 'custom', {framework:'Hyperloop', name:'Custom'}, output, '.m');

	} else {
		// delete in case we're re-generating
		var fn = path.join(dir, 'hyperloop', 'custom.m');
		fs.existsSync(fn) && fs.unlinkSync(fn);

		fn = path.join(dir, 'hyperloop', 'custom.js');
		fs.existsSync(fn) && fs.unlinkSync(fn);
	}
};

/**
 * parse a buf of JS into a state object
 */
Parser.prototype.parse = function (buf, fn, state) {

	if (typeof(state) === 'undefined') {
		state = {};
	} else {
		state = state.state;
	}

	// preserve across multiple files
	state.classesByName = state.classesByName || {};

	// reset these per module
	state.classesByVariable = {};
	state.referencedClasses = {};

	// turn it into a buffer
	buf = buf.toString();

	// fast return
	if (buf.indexOf('Hyperloop') < 0) {
		return new ParserState(state);
	}

	var ast = acorn.parse(buf, { locations: true });

	walk(ast, function (node) {
		// console.log(node.type);
		node.loc.filename = fn;
		if (isHyperloopMethodCall(node, 'defineClass')) {
			if (node.parentNode.type !== 'VariableDeclaration') {
				throw new JSParseError('Hyperloop.defineClass must return a class definition into a variable', node);
			}
			// if (!node.parentNode.parentNode || node.parentNode.parentNode.type !== 'Program') {
			// 	throw new JSParseError('Hyperloop.defineClass must be at the module root', node);
			// }
			var classSpec = makeHyperloopClassFromCall(node);
			if (classSpec.name in state.classesByName) {
				throw new JSParseError('Hyperloop.defineClass cannot define multiple classes with the same name "' + classSpec.name + '"', node);
			}
			if (classSpec.variable in state.classesByVariable) {
				throw new JSParseError('Hyperloop.defineClass cannot define multiple classes with the same variable name "' + classSpec.variable + '"', node);
			}
			state.classesByName[classSpec.name] = classSpec;
			state.classesByVariable[classSpec.variable] = classSpec;
		} else if (isHyperloopAddMethodCall(node, state)) {
			addHyperloopMethodToClass(node, state);
		} else if (isHyperloopReferenced(node, state)) {
			// just record
		}
	});

	return new ParserState(state);
};

function isHyperloopMethodCall (node, method) {
	return node &&
		node.type === 'CallExpression' &&
		node.callee &&
		node.callee.type === 'MemberExpression' &&
		node.callee.object &&
		node.callee.object.type === 'Identifier' &&
		node.callee.object.name === 'Hyperloop' &&
		node.callee.property &&
		node.callee.property.type === 'Identifier' &&
		node.callee.property.name === method;
}

function isHyperloopAddMethodCall (node, state) {
	return node &&
		node.type === 'CallExpression' &&
		node.callee &&
		node.callee.type === 'MemberExpression' &&
		node.callee.property &&
		node.callee.property.type === 'Identifier' &&
		node.callee.property.name === 'addMethod' &&
		node.callee.object &&
		node.callee.object.type === 'Identifier' &&
		node.callee.object.name in state.classesByVariable;
}

function isHyperloopReferenced (node, state) {
	if (node.type === 'Identifier' && node.name in state.classesByVariable) {
		if (!isHyperloopAddMethodCall(node.parentNode && node.parentNode.parentNode, state)) {
			var classDef = state.classesByVariable[node.name];
			state.referencedClasses[classDef.name] = (state.referencedClasses[classDef.name] || 0) + 1;
		}
	}
}

function findVariableDefinition (program, name, def) {
	var body = program.body;
	for (var c = 0; c < body.length; c++) {
		var node = body[c];
		if (node.type === 'VariableDeclaration') {
			for (var i = 0; i < node.declarations.length; i++) {
				var decl = node.declarations[i];
				if (decl.type === 'VariableDeclarator' && decl.id && decl.id.type === 'Identifier' && decl.id.name === name) {
					return toJSObject(program, decl.init);
				}
			}
		}
	}
	if (def) {
		return def;
	}
	throw new JSParseError('could not find variable "' + name + '"', program);
}

function toJSObject (ref, node, def) {
	if (node) {
		switch (node.type) {
			case 'Literal': {
				return node.value;
			}
			case 'ArrayExpression': {
				return node.elements.map(function (el) {
					return toJSObject(ref, el);
				});
			}
			case 'ObjectExpression': {
				var result = {};
				node.properties.forEach(function (p) {
					result[toJSObject(ref, p.key)] = toJSObject(ref, p.value);
				});
				return result;
			}
			case 'Identifier': {
				return findVariableDefinition(ref, node.name, node.name);
			}
			case 'BinaryExpression': {
				var left = toJSObject(ref, node.left);
				var right = toJSObject(ref, node.right);
				return left + right;
			}
			case 'FunctionExpression': {
				return node;
			}
		}
		throw new JSParseError("not sure what to do with this node", node);
	} else {
		return def;
	}
}

/**
 * example call:
 *
 * var MyUIView = Hyperloop.defineClass('MyUIView', 'UIView', ['Foo']);
 */
function makeHyperloopClassFromCall (node) {
	var classSpec = {};
	if (node.arguments.length < 2) {
		throw new JSParseError('Hyperloop.defineClass requires at least 2 arguments (className, extends)', node);
	}
	var program = findProgramNode(node);
	classSpec.name = toJSObject(program, node.arguments[0]);
	classSpec.extends = toJSObject(program, node.arguments[1]);
	classSpec.implements = toJSObject(program, node.arguments[2]);
	classSpec.variable = node.parentNode.declarations[0].id.name;
	classSpec.location = node.loc;
	return classSpec;
}

function findProgramNode (node) {
	var parent = node;
	while (parent && parent.type !== 'Program') {
		parent = parent.parentNode;
	}
	return parent;
}

function addHyperloopMethodToClass (node, state) {
	var name = node.callee.object.name;
	var classSpec = state.classesByVariable[name];
	classSpec.methods = classSpec.methods || {};
	if (!node.arguments || !node.arguments.length) {
		throw new JSParseError('addMethod requires at least 1 argument (methodSpec)', node);
	}
	var methodSpec = toJSObject(findProgramNode(node), node.arguments[0]);
	['selector', 'encoding', 'callback'].forEach(function(n) {
		if (!(n in methodSpec)) {
			throw new JSParseError('addMethod argument requires a "' + n + '" property which is the name of the method', node);
		}
	});
	if (methodSpec.selector in classSpec.methods) {
		throw new JSParseError('addMethod cannot add selector "' + methodSpec.selector + '" which already has been added', node);
	}
	methodSpec.instance = methodSpec.instance === undefined ? true : methodSpec.instance;
	// throw this away
	delete methodSpec.callback;
	classSpec.methods[methodSpec.selector] = methodSpec;
}

module.exports = Parser;

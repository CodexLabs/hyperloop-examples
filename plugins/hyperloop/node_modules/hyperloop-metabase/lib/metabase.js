/**
 * Hyperloop Metabase Generator
 * Copyright (c) 2015 by Appcelerator, Inc.
 */
var spawn = require('child_process').spawn,
	exec = require('child_process').exec,
	path = require('path'),
	fs = require('fs'),
	plist = require('plist'),
	async = require('async'),
	semver = require('semver'),
	crypto = require('crypto'),
	util = require('./generate/util'),
	binary = path.join(__dirname, '..', 'bin', 'metabase');


/**
 * return the configured SDK path
 */
function getSDKPath (sdkType, callback) {
	exec('/usr/bin/xcrun --sdk ' + sdkType + ' --show-sdk-path', function (err, stdout) {
		if (err) { return callback(err); }
		return callback(null, stdout.trim());
	});
}

/**
 * convert an apple style version (9.0) to a semver compatible version
 */
function appleVersionToSemver (ver) {
	var v = String(ver).split('.');
	if (v.length === 1) {
		return ver + '.0.0';
	}
	if (v.length === 2) {
		return ver + '.0';
	}
	return ver;
}

/**
 * return a parsed plist for a given framework
 */
function getPlistForFramework (info, callback) {
	if (fs.existsSync(info)) {
		var child = spawn('/usr/bin/plutil',['-convert', 'xml1', info, '-o', '-']);
		var out = '';
		child.stdout.on('data', function (buf) {
			out += buf.toString();
		});
		child.on('close', function (ex) {
			if (ex) {
				return callback(new Error("plistutil cannot convert " + info));
			}
			var result = plist.parse(out);
			return callback(null, result);
		});
	} else {
		return callback();
	}
}

var implRE = /@interface\s*(.*)/g;

function extractImplementations (fn, files) {
	var content = fs.readFileSync(fn).toString();
	var matches = content.match(implRE);
	var found = 0;
	if (matches && matches.length) {
		matches.forEach(function (match) {
			// skip categories
			if (match.indexOf('(') < 0) {
				var m = match.substring(11);
				var i = m.indexOf(':');
				// make sure this is an actual declaration (vs. comment);
				if (i > 0) {
					m = m.substring(0, i).trim();
					// trim off any qualifiers such as
					// @interface NSSet<__covariant ObjectType>
					i = m.indexOf('<');
					if (i > 0) {
						m = m.substring(0, i).trim();
					}
					files[m] = fn;
					found++;
				}
			}
		});
	}
	if (!found) {
		files[path.basename(fn).replace('.h','').trim()] = fn;
	}
}

/**
 * generate system framework includes mapping
 */
function generateSystemFrameworks (sdkPath, iosMinVersion, callback) {
	var skip = [],
		frameworkPath = path.resolve(path.join(sdkPath,'System/Library/Frameworks')),
		frameworks = fs.readdirSync(frameworkPath).filter(function(n){ return /\.framework$/.test(n) && !!~~skip.indexOf(n); }),
		iosMinVersionSemver = appleVersionToSemver(iosMinVersion),
		mapping = {};

	async.each(frameworks, function (fw, next) {
		var hd = path.join(frameworkPath, fw, 'Headers'),
			fp = path.join(hd, fw.replace('.framework','.h'));
		if (fs.existsSync(fp)) {
			getPlistForFramework(path.join(frameworkPath, fw, 'Info.plist'), function (err, p) {
				if (err) { return next(err); }
				// check min version
				if (p && p.MinimumOSVersion) {
					if (semver.gt(iosMinVersionSemver, appleVersionToSemver(p.MinimumOSVersion))) {
						return;
					}
				}
				if (p && p.UIDeviceFamily) {
					// TODO: check device family we are targeting
				}
				var files = {};
				fs.readdirSync(hd).forEach(function (n) {
					extractImplementations(path.join(hd, n), files);
				});
				mapping[fw.replace('.framework', '')] = files;
				next();
			});
		}
		else {
			return next();
		}
	}, function (err) {
		return callback(err, mapping);
	});
}

/**
 * generate a metabase
 *
 * @param {String} buildDir cache directory to write the files
 * @param {String} sdk the sdk type such as iphonesimulator
 * @param {String} iosMinVersion the min version such as 9.0
 * @param {Array} includes array of header paths (should be absolute paths)
 * @param {Boolean} excludeSystem if true, will exclude any system libraries in the generated output
 * @param {Function} callback function to receive the result which will be (err, json, json_file, header_file)
 * @param {Boolean} force if true, will not use cache
 */
function generateMetabase (buildDir, sdk, sdkPath, iosMinVersion, includes, excludeSystem, callback, force, extraHeaders) {
	var cacheToken = crypto.createHash('md5').update(sdkPath + iosMinVersion + excludeSystem + JSON.stringify(includes)).digest('hex');
	var header = path.join(buildDir, 'metabase-' + iosMinVersion + '-' + sdk + '-' + cacheToken + '.h');
	var outfile = path.join(buildDir, 'metabase-' + iosMinVersion + '-' + sdk + '-' + cacheToken + '.json');

	// check for cached version and attempt to return if found
	if (!force && fs.existsSync(header) && fs.existsSync(outfile)) {
		try {
			return callback(null, JSON.parse(fs.readFileSync(outfile)), path.resolve(outfile), path.resolve(header), true);
		}
		catch (e) {
			// fall through and re-generate again
		}
	}

	force && util.logger.trace('forcing generation of metabase to', outfile);

	var contents =  '/**\n' +
					' * HYPERLOOP GENERATED - DO NOT MODIFY\n' +
					' */\n' +
					includes.map(function (fn) {
						if (fn) {
							if (fn.charAt(0) === '<') {
								return '#import ' + fn;
							} else {
								return '#import "' + fn + '"';
							}
						}
					}).join('\n') +
					'\n';
	fs.writeFileSync(header, contents);
	var args = [
		'-i', path.resolve(header),
		'-o', path.resolve(outfile),
		'-sim-sdk-path', sdkPath,
		'-min-ios-ver', iosMinVersion,
		'-pretty'
	];
	if (excludeSystem) {
		args.push('-x');
	}
	if (extraHeaders) {
		args.push('-hsp');
		args.push('"' + extraHeaders.join(',') + '"');
	}
	util.logger.trace('running', binary, 'with', args.join(' '));
	var ts = Date.now();
	var child = spawn(binary, args);
	child.stdout.on('data', function (buf) {
		// process.stdout.write(buf);
		util.logger.debug(String(buf).replace(/\n$/,''));
	});
	child.stderr.on('data', function (buf) {
		// process.stderr.write(buf);
		// util.logger.error(String(buf).replace(/\n$/,''));
	});
	child.on('error', callback);
	child.on('exit', function (ex) {
		util.logger.trace('metabase took', (Date.now()-ts), 'ms to generate');
		if (ex) {
			return callback(new Error('Metabase generation failed'));
		}
		return callback(null, JSON.parse(fs.readFileSync(outfile)), path.resolve(outfile), path.resolve(header), false);
	});
}

/**
 * return the system frameworks mappings as JSON for a given sdkType and minVersion
 */
function getSystemFrameworks (cacheDir, sdkType, minVersion, callback) {
	var fn = 'metabase-mappings-' + sdkType + '-' + minVersion + '.json';
	if (!fs.existsSync(cacheDir)) {
		fs.mkdirSync(cacheDir);
	}
	var cacheFilename = path.join(cacheDir, fn);
	if (fs.existsSync(cacheFilename)) {
		try {
			return callback(null, JSON.parse(fs.readdirSync(cacheFilename)));
		} catch (E) {
			// errors, re-generate it
		}
	}
	getSDKPath(sdkType, function (err, sdkPath) {
		if (err) { return callback(err); }
		generateSystemFrameworks(sdkPath, minVersion, function (err, json) {
			if (err) { return callback(err); }
			json.$metadata = {
				sdkType: sdkType,
				minVersion: minVersion,
				sdkPath: sdkPath
			};
			fs.writeFileSync(cacheFilename, JSON.stringify(json));
			callback(null, json);
		});
	});
}

// public API
exports.getSystemFrameworks = getSystemFrameworks;
exports.generateMetabase = generateMetabase;

if (module.id === ".") {
	getSystemFrameworks('build', 'iphonesimulator', '9.0', function (err, json) {
		// console.log(require('util').inspect(json, {colors:true, depth:100}));
		// process.exit(1);
		var includes = [];
		includes.push(json.Foundation.NSURLSession);
		includes.push(json.UIKit.UIView);
		includes.push(json.CoreGraphics.CGRectMake);
		includes.push(json.Foundation.NSString);
		includes.push(json.UIKit.UIViewController);
		includes.push(json.UIKit.UIScreen);
		includes.push(json.UIKit.NSLayoutConstraint);
		includes.push(json.UIKit.UILabel);
		includes.push(json.Foundation.NSMutableAttributedString);
		includes.push(json.UIKit.NSAttributedString);
		generateMetabase('build', json.$metadata.sdkType, json.$metadata.sdkPath, json.$metadata.minVersion, includes, false, function (err, result) {
			// console.log(require('util').inspect(result, {colors:true, depth:100}));
		}, true);
		// generateMetabase('build', json.$metadata.sdkType, json.$metadata.sdkPath, json.$metadata.minVersion, includes, false, function (err, result) {
		// 	console.log(require('util').inspect(result, {colors:true, depth:100}));
		// }, 1, ['/Users/jhaynie/Library/Application Support/Titanium/mobilesdk/osx/5.1.0/iphone/include',
		// 	'/Users/jhaynie/Library/Application Support/Titanium/mobilesdk/osx/5.1.0/iphone/include/TiCore',
		// 	'/Users/jhaynie/Library/Application Support/Titanium/mobilesdk/osx/5.1.0/iphone/include/JavaScriptCore']);
	});
}
